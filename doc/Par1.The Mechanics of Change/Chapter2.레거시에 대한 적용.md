# 레거시에 대한 적용  

## 테스트를 통한 코드 보호

### 레거시에 대한 변경 시 가장 중요한 것
#### 변경을 가할 코드 주위에 테스트 루틴을 배치하는 것은 언제나 안전성을 높여준다.
* 사람이 코드를 변경할 때는 오류가 생기기 마련  
  * 변경 전 테스트 루틴으로 코드 보호  
    > 발생한 오류를 좀 더 쉽게 잡아낼 수 있다.  

### 의존성 : 레거시에 대한 변경을 어렵게 만드는 원인
> 테스트 하기 어려운 무언가에 **직접 의존**하는 코드는 다루거나 수정하기가 어렵다.  

#### 레거시 코드 딜레마 (순환 의존하는 작업 순서)  
> 코드 변경을 위해 테스트 코드 배치가 필요하고, 테스트 코드 배치를 위해 코드 변경이 필요한 경우

* 어떻게 끊을 것인가?  
  > 모든 경우에 적용할 수 없지만 기본적인 리팩토링 기법들  
  * primitive paramter  
    // STANDALONE CLASS 패턴으로 확장할 수 있을 듯  
  * extract interface  
    // extract interface의 적용 시기와 적용 방법에 대해서는 정답이 없다.  
  
* 보수적인 작업  
  > 중요한 것은 초기 단계부터 매우 보수적으로 리팩토링을 수행하는 것이다.  
  ```
  로또, 사다리 TDD 연습할 때 나왔던 케이스
  https://github.com/ddingcham/TIL/blob/b74dbd1823ace8d2b34b5d500e9ff2f2dfff6478/201810_4th/README.md#20181103
  ```
  
  * 코드 보호를 위한 의존 관계 제거 작업은 깔끔하게 되지 않을 수 있다.  
    > 실제론 필요 없는 매개변수의 추가, 단지 테스트 루틴을 위한 클래스의 분할  
  * 일부 코드의 품질이 변경 전보다 악화된 것 처럼 보일 수 있다.  
    > 하지만 위험 관리의 관점에서 본다면, 품질 악화를 유지하는 편이 낫다.  
  * 의존 관계 제거 작업 후 남은 **코드 흉터**는 나중에 제거할 수 있다.  
    > 미적 감각을 다소 내려놓아야 한다.  
    
#### 어찌 됐건, 코드 품질보다 중요한 것은 
#### 사용자가 원하는 동작이다.

## 레거시 코드를 변경하는 순서  
### 일반적인 레거시 코드 변경 알고리즘  
1. 변경 지점을 식별한다.  
  > 소프트웨어 아키텍처와 연관  
  > 16장, 17장 참조  
2. 테스트 루틴을 작성할 위치를 찾는다.  
  > 일반적으로, 레거시 코드의 경우 테스트 루틴 작성 위치를 찾기 어렵다.  
  > 11장, 12장 참조
3. **의존 관계를 제거한다.**  
4. 테스트 루틴을 작성한다.  
  > 레거시 코드에서의 테스트가 맡은 역할  
  > 13장 참조  
5. **변경 및 리팩토링을 수행한다.**  

#### 좀 더 가치 있는 방향으로 기능을 개선함과 동시에  
#### 테스트로 보호받는 시스템 내의 영역을 확대하는 것

### 의존 관계를 제거한다.
테스트 하네스 내부에서 의존 관계가 문제가 되는 경우
  > 객체 인스턴스 생성  
  > 메소드 실행  
  
* 23장  
  > 테스트를 통해 시스템을 보호할 때 최초의 작업을 좀 더 안전하게  
  > 실용적인 기법 위주  
* 9장, 10장  
  > 일반적인 의존 관계 해결 시나리오  
* 25장  
  > 의존 관계 제거 기법 목록  
* 22장  
  > 대규모 메소드 내에 존재하는 의존 관계들 때문에 테스트 루틴 작성이 어려운 경우  
* 7장  
  > 테스트 루틴 작성 시간이 너무 오래 걸릴 경우(의존 관계 제거 방법은 알겠는데...)  


### 변경 및 리팩토링을 수행한다.
* 8장  
> TDD를 비롯한 몇 가지 기법들  
* 20장 ~ 22장  
> 레거시 코드의 구조 개선을 위한 일반적인 기법들  
> 이상적인 방법들은 아니지만, 대부분의 경우 효과는 볼 수 있음  
> 이상적인 방법은 해당 케이스에 대한 자료를 참고할 것  

