# 감지와 분리
// 클래스들 간에 의존 관계가 존재하기 때문에 특정 객체들만  
// 테스트 루틴으로 보호하는 것은 매우 어려울 때가 많다.
> 줄줄이 이어지는 의존성 ...  
#### 다른 클래스인 것처럼 위장해서 직접 감지하는 수밖에 없다.

* **테스트 루틴 배치 시 의존 관계를 제거하는 이유**
  * **감지**  
    > 코드 내에서 계산된 값에 접근할 수 없을 때,  
    > 이를 감지하기 위해 의존 관계를 제거한다.  
  * **분리**  
    > 코드를 테스트 하네스 내에 넣어서 실행할 수 없을 때,  
    > 코드를 분리하기 위해 의존 관계를 제거한다.  

## ex] NetworkBridge
```
public class NetworkBridge
{
  public NetworkBridge(EndPoint [] endpoints) {...}
  public void formRouting(String sourceID, String destID) {...}
  ...
}
```
### NetworkBridge
* NetworkBridge는 EndPoint 배열을 입력받는다.  
  > 로컬 하드웨어를 사용해 설정을 관리한다.  
  > 사용자는 NetworkBridge를 통해 트래픽 경로를 제어할 수 있다.  
    >> 하나의 종점에서 다른 종점까지  

* NetworkBridge 클래스는 제어 작업을 수행하기 위해  
  > EndPoint 클래스의 설정을 변경한다.  
  > EndPoint 인스턴스들은 소켓을 열고 특정 장치와 통신할 수 있다.  
  
// 테스트하기 어려울 것 같은 느낌 : **네트워크를 통한 통신**

### 테스트 루틴을 작성해 보자  
* 고려 사항   
  * NetworkBridge instance object는 실제 하드웨어를 자주 호출한다.  
    > 생성을 위해 실제 하드웨어 필요 여부  
  * 하드웨어(네트워크 종점, EndPoint)에 대한 작업 정보  
    > BlackBox 내부를 들여다 보는 것은 불편하다.
    > BlackBox화 한 이유는 있을 것 이다.  

* 다양한 해결책과 최적해  
  * 네트워크상의 패킷을 읽는 코드를 작성해야 하나?  
  * NetworkBridge 인스턴스 생성 시 프리징 현상을 예방하기 위해,  
    새로운 하드웨어가 필요한가?  
  * 네트워크 종점들의 로컬 클러스터를 구성해 테스트하려고,  
    새로운 배선작업을 해야할까?  
> 레이어를, 모듈을, 컴포넌트를 추상화하여 나누는 이유를 고려한다면 ....   

* 최적해에 대한 고민  
  > 우리의 문제는 단순히 NetworkBridge 클래스의 객체를 실행할 수 없으므로  
  > 어떻게 동작할지 직접 확인할 수 없는 것이다.  
    #### 이해하지 못한 것에 대한 과분한 노력과 비용을 투입하려는 건 아닌지 고려해야한다.  
    #### NetworkBridge에 대한 테스트 하네스는 NetworkBridge 클래스의 책임(로직)만 고려한다.  

* **감지와 분리**의 적용  
  일반적으로 둘 다 필요하며, 둘 다 의존관계를 제거하는 이유가 된다.  
  **분리**에 사용되는 기법은 매우 다양하다. (정답이 없는 문제라고 하는)  
  **감지**의 경우에는 일반적인 기법이 존재한다. ((아래)협업 클래스 위장하기)  

## 협업 클래스 위장하기 _ 
