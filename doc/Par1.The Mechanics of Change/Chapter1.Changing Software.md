# 소프트웨어 변경

## 소프트웨어 코드를 변경하는 네 가지 이유
* 새로운 기능(feature)의 추가  
* 버그 수정  
* 설계 개선  
* 자원 이용의 최적화  

## 기능 추가와 버그 수정

단순히 회사의 로고 위치를 바꾼다면...  
* 요구사항에 대한 **관점**  
  * 고객 관점  
    현업 담당자는 웹사이트를 보고, 부서 회의를 통해  
    * **로고 위치 변경 및 약간의 기능 추가 요청**
      > 약간의 애니메이션 효과  
  
  * 개발자 관점  
    * 완전히 새로운 기능을 추가하는 작업  
    
  * 조직 관점  
    > 개발자가 실제로는 새로운 작업을 해야 함에도 불구하고  
    > 로고 이동을 단순한 버그 수정 정도로만 여기는 때가 많다.  
    
#### 보는 사람의 관점에 따라 새로운 기능 추가인지 버그 수정인지에 대한 판단은 다를 수 있다.
하지만, 어느 경우든
#### 소프트웨어 코드 및 그 밖의 산출물을 변경해야 한다는 사실에는 변함이 없다.  

### 좀 더 중요한 사실 : 동작 변경(behavioral change)
> **새로운 동작을 추가하는 것**과 **기존의 동작을 변경하는 것** 간의 커다란 차이  
  
* **동작**(behavior)
  * **동작**은 소프트웨어에서 가장 중요한 것이다.  
  * 사용자가 원하는 것은 **동작**이다.  
    * 사용자가 원하는 동작을 추가하면,  
      > 사용자는 소프트웨어를 좋아한다.  
    * 사용자가 원하는 동작을 변경하거나, 삭제하면, 버그를 발생시키면  
      > **사용자들은 우리를 더 이상 신뢰하지 않는다.**  
  
  * 웹 페이지 로고 이동  
    * 새로운 동작의 추가  
      > 화면 오른편에 회사 로고 표시  
    * 제거되는 동작  
      > 화면 왼편에 회사 로고의 사라짐  
      
    * **처음부터 화면 왼편에 로고가 없는 상태에서 오른편에 추가**  
      > 새로운 동작이 추가? 제거되는 동작은? 새롭게 로고가 그려질 자리에 무언가가 존재하고 있었는가?  
      > 동작의 변경? 추가? 둘 다?  
   
#### 프로그래머 관점에서의 기준 정립  
* 기존 코드를 변경해야 한다면?  
  > 동작 변경  
* 새로운 코드를 추가하고, 호출할 뿐이라면?  
  > 동작 추가
  
* 코드 관점
```
public class CDPlayer {
  ...
  public void addTrackListing(Track track){}
  ...
}
```
  * 노래 목록을 교체하는 메소드 추가  
  ```
  public void replaceTrackListing(String name, Track track){}
  ```
  * 어떻게 바라봐야 하나?  
    * 애플리케이션에 새로운 동작을 추가했거나, 기존 동작을 변경했을까?  
      > 아니다. (아무 동작도 변경되지 않았다.)  
  
  * CD 플레이어 UI에 새로운 버튼을 추가한다면?  
    // 사용자는 이 버튼으로 노래 목록을 교체할 수 있다.  
    > replaceTrackListing() 메소드에 동작을 추가  
    > 동시에 약간의 동작 변경도 포함 (UI에 대한 변경)  
      >> 어쩌면, UI가 화면에 표시되는 시간이 매우 조금 느려질지도 모른다.  
      
#### 어느 정도의 동작 변경 없이 동작을 추가하는 것은 거의 불가능 하다.

## 설계 개선  
설계 개선은 또 다른 종류의 소프트웨어 변경 사유  

### 많은 프로그래머들이 설계 개선을 주저하는 이유  
* 설계 개선?  
  > 소프트웨어의 구조를 좀 더 유지 보수하기에 쉬운 구조로 변경하고 싶을 때  
  > 일반적으로 소프트웨어의 동작은 건드리지 않는다.  
* **버그** // side effect  
  > 이 과정에서 어떤 동작이 제거되면 이를 버그라고 부를 때가 많다.  
    
#### 설계 개선 과정에서 특정 동작이 누락되거나, 원치 않는 동작이 만들어지기 쉽다.

### 리팩토링 : 동작 변경 없이 설계를 개선하는 행위  
* 기초 개념  
  * 테스트 루틴 작성  
    > 기존 동작이 변경되지 않았음을 확인  
  * 테스트 루틴의 검증  
  * 단계별로 설계 개선 진행  
  * 소프트웨어의 유지 보수성 향상  
  
* 코드 정리와의 구별  
#### 리팩토링은 코드 재구성, 재작성을 의미하지 않는다. (코드 정리)
> 리팩토링은 일련의 **소규모 구조 변경**을 반복하면서  
> 코드 변경을 쉽게하기 위한 테스트 루틴의 뒷받침을 받는다.
#### 가장 중요한 것은 리팩토링 전후에 기능상의 변경이 없어야 한다는 점이다.
> 기능상의 변경과 성능상의 변경을 구분짓는 것에 주목  

## 최적화
* 리팩토링과의 공통점  
  * 소프트웨어는 **변경하면서**  
  * 기존의 기능은 **변경하지 않는다.**  
> **무언가**는 변경한다.

### 리팩토링과 다른 목적
* 리팩토링 : **유지보수성의 개선**  
  > **구조를 변경**  
  
* 최적화 : **리소스**  
  > 프로그램이 사용하는 시간이나 메모리 등  
  
## 네 가지 이유의 종합  
#### 우리가 시스템에서 어떤 작업을 할 때 세 가지 서로 다른 것이 변경될 수 있다.  
* 구조  
* 기능  
* 리소스 사용량  

### 무엇에 집중할 것인가?  

* **소프트웨어 변경 행위별** 변경 대상  
| 분류 | 기능 추가 | 버그 수정 | 리팩토링 | 최적화 |  
| 구조 | 변경 | 변경 | 변경 | - |  
| 새로운 기능 | 변경 | - | - | - |  
| 기능 | - | 변경 | - | - |  
| 자원 사용량 | - | - | - | 변경 |  

#### 변경 대상 코드에만 집중하면 안 된다.  
#### 불행히도, 기존의 동작을 그대로 유지한다는 것은 단순히 코드를 그대로 두는 것 이상의 의미를 갖는다.  
> 안전한 변경을 수행하기 위해서는 영향이 미치는 범위를 정확히 이해하는 것이 가장 중요하다.  
> 효율적인 변경을 수행하기 위해서는 현재 작업에 필요한 테스트 루틴만 적용 시켜야한다.  

## 위험한 변경  
* 위험의 최소화  
  1. 어떤 변경을 해야 하는가?  
  2. 변경이 정확하게 이뤄졌는지 어떻게 확인할 수 있는가?  
  3. 무언가를 손상시키지 않았는지 어떻게 확인할 수 있는가?  
> 위험이 따르는 변경이라면, **우리는 얼마나 위험을 감수할 수 있는가?**  

### 변경 회피와 이슈들
* 적은 변경(**보수적인**)은 더 안전한가?  
  > 클래스와 메소드를 새로 생성하지 않으면,  
  > 기존의 클래스와 메소드는 **갈수록 비대해져서**  
  > 결국 코드를 이해하기 어려운 지경에 이른다.  
  
* 나쁜 시스템의 경우 알면 알수록 망설임이 커진다.  
  > 결국 점 점 더 나빠진다.  
  
* 변경을 자주 하지 않으면 개발자의 실력이 녹슬기 쉽다.  
  > 거대한 클래스를 분할하는 작업을 꾸준히 하지 않으면,  
  > 나중에는 감당하기 힘든 수준이 된다.  
  
#### 분할에 대한 꾸준한 수행과 습관은 점점 더 잘 판단하게 해준다.
#### 더 나은 기법의 수련을 통해 두려움이 줄어들 때,
#### 과거의 두려움에 대해 깨닫곤 한다.  

### 우리는 안전한 변경을 수행중인가? -> 피드백 활용  
