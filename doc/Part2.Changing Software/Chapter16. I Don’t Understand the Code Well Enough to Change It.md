# 변경이 가능할 만큼 코드를 이해하지 못하는 경우  
I Don’t Understand the Code Well Enough to Change It
 
#### 코드를 이해하는 방법은 다양하지만...
```
대부분의 사람은 가장 직접적인 방법(코드읽기)에만 사로잡혀서 다른 방법들은 사용하지 않는다.  
그 결과, 코드 이해에 많은 시간을 들여봤자 별 효과가 없다고 생각하게 된다.
...
간단하면서 그리 복잡하지 않은 몇 가지 작업들을 통해 확고한 기반을 쌓을 수 있다.
```
* 노트/스케치  
* 표시 나열  
* 스크래치 리팩토링  
* 미사용(//중복) 코드 삭제  

## 노트/스케치  

### 그림을 그리거나 노트에 메모하는 것이 효과적이다.  
* 중요 사항 이름 적기  
  > 가장 마지막으로 본 중요 사항을 시작으로 ...  
  > 중요 사항들을 찾아나간다.  

* 그들 사이에 어떤 관계가 있다면  
  > 연관 관계에 대한 선을 긋는다.  
  > UML 문법이나, 기타 표기법을 완벽하게 따를 필요는 없다.  
  
복잡해진 노트/스케치를 효율적으로 표현하기 위해 
#### 정형화된 표기법이 사용하고 싶어질 때 따르면 된다.

#### 스케치를 그려봄으로써 기존과는 다른 각도로 대상을 바라볼 수 있다.

### 의식적으로 "심적 표상" 배출하고, 수정하기  
// 1만 시간의 재발견  
// 노트/스케치 -> 심적 표상의 배출/수정  
```
"심적 표상이란 사물, 관념, 정보, 이외에 구체적이든 추상적이든 뇌가 생각하고 있는 대상에 상응하는 심적 구조물이다. 
예를 들어 '모나리자'라고 하면, 많은 사람이 즉시 머릿속에 해당 그림의 '이미지'를 본다. 
이때 머릿속에 떠오른 이미지가 모나리자에 대한 사람들의 심적 표상이다. 
어떤 사람의 심적 표상은 다른 사람보다 상세하고 정확하다. 
예를 들어 배경, 모나리자가 앉아있는 장소, 머리 모양, 눈썹 등을 상세하게 말할 수 있는 사람이 있는가 하면 그렇지 못한 사람도 있다."
```
#### 이번 경험이 다음 작업에 도움이 될 수 있도록 하는 연습

## 표시 나열
#### 매우 규모가 큰 메소드일 때 특히 유용하다.

### 표시 나열 기법은 이해하려는 대상에 따라 달라진다.
* 공통 사항  
  * 먼저 작업 대상 코드를 프린터로 출력한다.  
  * 아래의 용도에 따라 표시 나열 기법을 적용한다.  
  
* 책임 분리  
  > 대상을 그룹별로 나누기 위해 표시를 사용한다.  
  > 동일 그룹에 속하는 대상들을 식별하기 위해 특별한 기호를 표시  
  > 다양한 색을 활용하는 것도 효과적  
  
* 메소드 구조의 이해  
  * 메소드 내의 코드 블록  
    > indentation만으로는 이해가 힘들 수 있음  
    * 코드 블록의 처음 부분과 끝부분에 선긋기  
    * 블록의 끝부분에 그 블록이 시작된 반복/분기문의 문자열 적기  
    
  * 쉽게 선긋기  
    * 안쪽에서 바깥쪽으로 선긋기  
      > 블록의 시작에 대한 건 나중으로 미루고  
      > 특정 위치에서 최초로 블록이 종료(ex '}')될 때까지 그어 본다.  
      
    * 블록 종료 시점에 시작 위치를 찾아 반대로 긋는다.  
    
    * 위 두 단계를 반복한다.  
    
* 메소드 추출  
  * 추출하려는 코드 주변을 원으로 표시  
  * 결합 카운트(22장 참조)에 대한 주석을 단다.  
    
* 변경 영향의 이해  
  ```
  변경으로 인한 영향이 어떻게 전파되는지 이해하면,
  무엇을 테스트해야 할지 이해하는 데도 도움이 된다.
  ```  
영향 스케치(11장 참조)를 작성 할 수도 있지만...  
  * 변경하려는 코드에 직접 표시한다.  
  * 변경으로 인해 영향을 받을 가능성이 있는 변수와 메소드 호출에 표시한다.  
    * 전 단계에서 표시한 부분으로 인해 영향을 받게되는 변수와 메소드에 표시한다.  
    * 반복한다.  
  * 특별한 기호나 특별한 색으로 그루핑 하는 것도 효과적일 것 같음  

## 스크래치 리팩토링  
#### 리팩토링은 코드를 배우는 최선의 기법 중 하나  
#### 유일한 문제점은 테스트 루틴 없이는 위험할 수 있는 점  

* 스크래치 리팩토링 컨셉  
  > 테스트 루틴이 없이 버전 관리 시스템을 활용한다.  
  > 메소드 추출, 변수 이동 등 다양한 방법으로 마음껏 리팩토링  
    >> 리팩토링 시도가 코드를 이해하는 과정  
    
  > 체크인 하지말고 그냥 버리기  
  
  #### 시간 낭비가 아니다 -> 백견이 불여일타  
 
### 위험 요소  
#### 잘못 이해한 부분이 캐스케이딩됨
* 리팩토링 과정에서 착각 발생  
  > 잘못된 관점으로 인해 실질적인 리팩토링을 주저하게 하기도 함  
* 리팩토링 과정에서 발생한 착각에 맞춰서 생각  

#### "실제 리팩토링" 과정에서 "스크래치 리팩토링"의 결과에 너무 집착하지 말기  
> 정답이건 아니건 이해를 위한 인사이트를 쌓아두는 것일 뿐

## 미사용(//중복) 코드 삭제  
글도 말도 장황하면 이해하기 어렵다.  
### 그 코드를 작성하기 위해 누군가 시간을 들였고, 다시 사용될 수 있다는 생각  
#### 버전 관리 시스템이 할 일이다.  
